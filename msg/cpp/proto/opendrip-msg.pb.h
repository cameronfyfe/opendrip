// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/opendrip-msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fopendrip_2dmsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fopendrip_2dmsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fopendrip_2dmsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fopendrip_2dmsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fopendrip_2dmsg_2eproto;
class AgentConfig;
struct AgentConfigDefaultTypeInternal;
extern AgentConfigDefaultTypeInternal _AgentConfig_default_instance_;
class AgentInfo;
struct AgentInfoDefaultTypeInternal;
extern AgentInfoDefaultTypeInternal _AgentInfo_default_instance_;
class AgentInfo_PropertiesEntry_DoNotUse;
struct AgentInfo_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern AgentInfo_PropertiesEntry_DoNotUseDefaultTypeInternal _AgentInfo_PropertiesEntry_DoNotUse_default_instance_;
class AgentState;
struct AgentStateDefaultTypeInternal;
extern AgentStateDefaultTypeInternal _AgentState_default_instance_;
class ControllerConfig;
struct ControllerConfigDefaultTypeInternal;
extern ControllerConfigDefaultTypeInternal _ControllerConfig_default_instance_;
class ControllerInfo;
struct ControllerInfoDefaultTypeInternal;
extern ControllerInfoDefaultTypeInternal _ControllerInfo_default_instance_;
class ControllerInfo_PropertiesEntry_DoNotUse;
struct ControllerInfo_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern ControllerInfo_PropertiesEntry_DoNotUseDefaultTypeInternal _ControllerInfo_PropertiesEntry_DoNotUse_default_instance_;
class ControllerState;
struct ControllerStateDefaultTypeInternal;
extern ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
class DeviceConfig;
struct DeviceConfigDefaultTypeInternal;
extern DeviceConfigDefaultTypeInternal _DeviceConfig_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DeviceInfo_PropertiesEntry_DoNotUse;
struct DeviceInfo_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern DeviceInfo_PropertiesEntry_DoNotUseDefaultTypeInternal _DeviceInfo_PropertiesEntry_DoNotUse_default_instance_;
class DeviceState;
struct DeviceStateDefaultTypeInternal;
extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AgentConfig* Arena::CreateMaybeMessage<::AgentConfig>(Arena*);
template<> ::AgentInfo* Arena::CreateMaybeMessage<::AgentInfo>(Arena*);
template<> ::AgentInfo_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::AgentInfo_PropertiesEntry_DoNotUse>(Arena*);
template<> ::AgentState* Arena::CreateMaybeMessage<::AgentState>(Arena*);
template<> ::ControllerConfig* Arena::CreateMaybeMessage<::ControllerConfig>(Arena*);
template<> ::ControllerInfo* Arena::CreateMaybeMessage<::ControllerInfo>(Arena*);
template<> ::ControllerInfo_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ControllerInfo_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ControllerState* Arena::CreateMaybeMessage<::ControllerState>(Arena*);
template<> ::DeviceConfig* Arena::CreateMaybeMessage<::DeviceConfig>(Arena*);
template<> ::DeviceInfo* Arena::CreateMaybeMessage<::DeviceInfo>(Arena*);
template<> ::DeviceInfo_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::DeviceInfo_PropertiesEntry_DoNotUse>(Arena*);
template<> ::DeviceState* Arena::CreateMaybeMessage<::DeviceState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum DeviceType : int {
  VALVE = 0,
  FLOW_METER = 1,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = VALVE;
constexpr DeviceType DeviceType_MAX = FLOW_METER;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceType_descriptor();
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceType_descriptor(), enum_t_value);
}
inline bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum DeviceUnits : int {
  OPEN_CLOSE = 0,
  GALLONS_PER_MINUTE = 1,
  DeviceUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceUnits_IsValid(int value);
constexpr DeviceUnits DeviceUnits_MIN = OPEN_CLOSE;
constexpr DeviceUnits DeviceUnits_MAX = GALLONS_PER_MINUTE;
constexpr int DeviceUnits_ARRAYSIZE = DeviceUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceUnits_descriptor();
template<typename T>
inline const std::string& DeviceUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceUnits_descriptor(), enum_t_value);
}
inline bool DeviceUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceUnits>(
    DeviceUnits_descriptor(), name, value);
}
enum DeviceMode : int {
  AUTO = 0,
  MANUAL = 1,
  REMOTE = 2,
  DeviceMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceMode_IsValid(int value);
constexpr DeviceMode DeviceMode_MIN = AUTO;
constexpr DeviceMode DeviceMode_MAX = REMOTE;
constexpr int DeviceMode_ARRAYSIZE = DeviceMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceMode_descriptor();
template<typename T>
inline const std::string& DeviceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceMode_descriptor(), enum_t_value);
}
inline bool DeviceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceMode>(
    DeviceMode_descriptor(), name, value);
}
// ===================================================================

class DeviceInfo_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeviceInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeviceInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DeviceInfo_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DeviceInfo_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DeviceInfo_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DeviceInfo_PropertiesEntry_DoNotUse& other);
  static const DeviceInfo_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DeviceInfo_PropertiesEntry_DoNotUse*>(&_DeviceInfo_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "DeviceInfo.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "DeviceInfo.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};

// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceTypeCase {
    kStandardType = 3,
    kCustomType = 4,
    DEVICE_TYPE_NOT_SET = 0,
  };

  enum DeviceUnitsCase {
    kStandardUnit = 5,
    kCustomUnit = 6,
    DEVICE_UNITS_NOT_SET = 0,
  };

  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceInfo& from) {
    DeviceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 2,
    kNameFieldNumber = 1,
    kMinMsgIntervalMsFieldNumber = 7,
    kStandardTypeFieldNumber = 3,
    kCustomTypeFieldNumber = 4,
    kStandardUnitFieldNumber = 5,
    kCustomUnitFieldNumber = 6,
  };
  // map<string, string> properties = 2;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 min_msg_interval_ms = 7;
  void clear_min_msg_interval_ms();
  uint32_t min_msg_interval_ms() const;
  void set_min_msg_interval_ms(uint32_t value);
  private:
  uint32_t _internal_min_msg_interval_ms() const;
  void _internal_set_min_msg_interval_ms(uint32_t value);
  public:

  // .DeviceType standard_type = 3;
  bool has_standard_type() const;
  private:
  bool _internal_has_standard_type() const;
  public:
  void clear_standard_type();
  ::DeviceType standard_type() const;
  void set_standard_type(::DeviceType value);
  private:
  ::DeviceType _internal_standard_type() const;
  void _internal_set_standard_type(::DeviceType value);
  public:

  // string custom_type = 4;
  bool has_custom_type() const;
  private:
  bool _internal_has_custom_type() const;
  public:
  void clear_custom_type();
  const std::string& custom_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_type();
  PROTOBUF_NODISCARD std::string* release_custom_type();
  void set_allocated_custom_type(std::string* custom_type);
  private:
  const std::string& _internal_custom_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_type(const std::string& value);
  std::string* _internal_mutable_custom_type();
  public:

  // .DeviceUnits standard_unit = 5;
  bool has_standard_unit() const;
  private:
  bool _internal_has_standard_unit() const;
  public:
  void clear_standard_unit();
  ::DeviceUnits standard_unit() const;
  void set_standard_unit(::DeviceUnits value);
  private:
  ::DeviceUnits _internal_standard_unit() const;
  void _internal_set_standard_unit(::DeviceUnits value);
  public:

  // string custom_unit = 6;
  bool has_custom_unit() const;
  private:
  bool _internal_has_custom_unit() const;
  public:
  void clear_custom_unit();
  const std::string& custom_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_unit();
  PROTOBUF_NODISCARD std::string* release_custom_unit();
  void set_allocated_custom_unit(std::string* custom_unit);
  private:
  const std::string& _internal_custom_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_unit(const std::string& value);
  std::string* _internal_mutable_custom_unit();
  public:

  void clear_device_type();
  DeviceTypeCase device_type_case() const;
  void clear_device_units();
  DeviceUnitsCase device_units_case() const;
  // @@protoc_insertion_point(class_scope:DeviceInfo)
 private:
  class _Internal;
  void set_has_standard_type();
  void set_has_custom_type();
  void set_has_standard_unit();
  void set_has_custom_unit();

  inline bool has_device_type() const;
  inline void clear_has_device_type();

  inline bool has_device_units() const;
  inline void clear_has_device_units();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DeviceInfo_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t min_msg_interval_ms_;
    union DeviceTypeUnion {
      constexpr DeviceTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int standard_type_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_type_;
    } device_type_;
    union DeviceUnitsUnion {
      constexpr DeviceUnitsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int standard_unit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_unit_;
    } device_units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class DeviceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceConfig) */ {
 public:
  inline DeviceConfig() : DeviceConfig(nullptr) {}
  ~DeviceConfig() override;
  explicit PROTOBUF_CONSTEXPR DeviceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceConfig(const DeviceConfig& from);
  DeviceConfig(DeviceConfig&& from) noexcept
    : DeviceConfig() {
    *this = ::std::move(from);
  }

  inline DeviceConfig& operator=(const DeviceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceConfig& operator=(DeviceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceConfig* internal_default_instance() {
    return reinterpret_cast<const DeviceConfig*>(
               &_DeviceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeviceConfig& a, DeviceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceConfig& from) {
    DeviceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceConfig";
  }
  protected:
  explicit DeviceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceModeFieldNumber = 1,
    kMsgIntervalMsFieldNumber = 2,
  };
  // .DeviceMode device_mode = 1;
  void clear_device_mode();
  ::DeviceMode device_mode() const;
  void set_device_mode(::DeviceMode value);
  private:
  ::DeviceMode _internal_device_mode() const;
  void _internal_set_device_mode(::DeviceMode value);
  public:

  // uint32 msg_interval_ms = 2;
  void clear_msg_interval_ms();
  uint32_t msg_interval_ms() const;
  void set_msg_interval_ms(uint32_t value);
  private:
  uint32_t _internal_msg_interval_ms() const;
  void _internal_set_msg_interval_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DeviceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int device_mode_;
    uint32_t msg_interval_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class DeviceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceState) */ {
 public:
  inline DeviceState() : DeviceState(nullptr) {}
  ~DeviceState() override;
  explicit PROTOBUF_CONSTEXPR DeviceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceState(const DeviceState& from);
  DeviceState(DeviceState&& from) noexcept
    : DeviceState() {
    *this = ::std::move(from);
  }

  inline DeviceState& operator=(const DeviceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceState& operator=(DeviceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceState* internal_default_instance() {
    return reinterpret_cast<const DeviceState*>(
               &_DeviceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeviceState& a, DeviceState& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceState& from) {
    DeviceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceState";
  }
  protected:
  explicit DeviceState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:DeviceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class ControllerInfo_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ControllerInfo_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ControllerInfo_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ControllerInfo_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerInfo_PropertiesEntry_DoNotUse& other);
  static const ControllerInfo_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerInfo_PropertiesEntry_DoNotUse*>(&_ControllerInfo_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ControllerInfo.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ControllerInfo.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};

// -------------------------------------------------------------------

class ControllerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ControllerInfo) */ {
 public:
  inline ControllerInfo() : ControllerInfo(nullptr) {}
  ~ControllerInfo() override;
  explicit PROTOBUF_CONSTEXPR ControllerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerInfo(const ControllerInfo& from);
  ControllerInfo(ControllerInfo&& from) noexcept
    : ControllerInfo() {
    *this = ::std::move(from);
  }

  inline ControllerInfo& operator=(const ControllerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerInfo& operator=(ControllerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerInfo* internal_default_instance() {
    return reinterpret_cast<const ControllerInfo*>(
               &_ControllerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControllerInfo& a, ControllerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControllerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControllerInfo& from) {
    ControllerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ControllerInfo";
  }
  protected:
  explicit ControllerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 2,
    kDevicesFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // map<string, string> properties = 2;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // repeated string devices = 3;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  const std::string& devices(int index) const;
  std::string* mutable_devices(int index);
  void set_devices(int index, const std::string& value);
  void set_devices(int index, std::string&& value);
  void set_devices(int index, const char* value);
  void set_devices(int index, const char* value, size_t size);
  std::string* add_devices();
  void add_devices(const std::string& value);
  void add_devices(std::string&& value);
  void add_devices(const char* value);
  void add_devices(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& devices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_devices();
  private:
  const std::string& _internal_devices(int index) const;
  std::string* _internal_add_devices();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ControllerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ControllerInfo_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> devices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class ControllerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ControllerConfig) */ {
 public:
  inline ControllerConfig() : ControllerConfig(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ControllerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerConfig(const ControllerConfig& from);
  ControllerConfig(ControllerConfig&& from) noexcept
    : ControllerConfig() {
    *this = ::std::move(from);
  }

  inline ControllerConfig& operator=(const ControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerConfig& operator=(ControllerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerConfig* internal_default_instance() {
    return reinterpret_cast<const ControllerConfig*>(
               &_ControllerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControllerConfig& a, ControllerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ControllerConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ControllerConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ControllerConfig";
  }
  protected:
  explicit ControllerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ControllerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class ControllerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ControllerState) */ {
 public:
  inline ControllerState() : ControllerState(nullptr) {}
  ~ControllerState() override;
  explicit PROTOBUF_CONSTEXPR ControllerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControllerState(const ControllerState& from);
  ControllerState(ControllerState&& from) noexcept
    : ControllerState() {
    *this = ::std::move(from);
  }

  inline ControllerState& operator=(const ControllerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerState& operator=(ControllerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerState* internal_default_instance() {
    return reinterpret_cast<const ControllerState*>(
               &_ControllerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControllerState& a, ControllerState& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControllerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControllerState& from) {
    ControllerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ControllerState";
  }
  protected:
  explicit ControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUptimeSFieldNumber = 1,
  };
  // uint32 uptime_s = 1;
  void clear_uptime_s();
  uint32_t uptime_s() const;
  void set_uptime_s(uint32_t value);
  private:
  uint32_t _internal_uptime_s() const;
  void _internal_set_uptime_s(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ControllerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t uptime_s_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class AgentInfo_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentInfo_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AgentInfo_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AgentInfo_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentInfo_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentInfo_PropertiesEntry_DoNotUse& other);
  static const AgentInfo_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentInfo_PropertiesEntry_DoNotUse*>(&_AgentInfo_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "AgentInfo.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "AgentInfo.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};

// -------------------------------------------------------------------

class AgentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgentInfo) */ {
 public:
  inline AgentInfo() : AgentInfo(nullptr) {}
  ~AgentInfo() override;
  explicit PROTOBUF_CONSTEXPR AgentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentInfo(const AgentInfo& from);
  AgentInfo(AgentInfo&& from) noexcept
    : AgentInfo() {
    *this = ::std::move(from);
  }

  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentInfo& operator=(AgentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentInfo* internal_default_instance() {
    return reinterpret_cast<const AgentInfo*>(
               &_AgentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AgentInfo& a, AgentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentInfo& from) {
    AgentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgentInfo";
  }
  protected:
  explicit AgentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 2,
    kControllersFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // map<string, string> properties = 2;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // repeated string controllers = 3;
  int controllers_size() const;
  private:
  int _internal_controllers_size() const;
  public:
  void clear_controllers();
  const std::string& controllers(int index) const;
  std::string* mutable_controllers(int index);
  void set_controllers(int index, const std::string& value);
  void set_controllers(int index, std::string&& value);
  void set_controllers(int index, const char* value);
  void set_controllers(int index, const char* value, size_t size);
  std::string* add_controllers();
  void add_controllers(const std::string& value);
  void add_controllers(std::string&& value);
  void add_controllers(const char* value);
  void add_controllers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& controllers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_controllers();
  private:
  const std::string& _internal_controllers(int index) const;
  std::string* _internal_add_controllers();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:AgentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AgentInfo_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> controllers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class AgentConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:AgentConfig) */ {
 public:
  inline AgentConfig() : AgentConfig(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AgentConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentConfig(const AgentConfig& from);
  AgentConfig(AgentConfig&& from) noexcept
    : AgentConfig() {
    *this = ::std::move(from);
  }

  inline AgentConfig& operator=(const AgentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentConfig& operator=(AgentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentConfig* internal_default_instance() {
    return reinterpret_cast<const AgentConfig*>(
               &_AgentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AgentConfig& a, AgentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AgentConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AgentConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgentConfig";
  }
  protected:
  explicit AgentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AgentConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// -------------------------------------------------------------------

class AgentState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgentState) */ {
 public:
  inline AgentState() : AgentState(nullptr) {}
  ~AgentState() override;
  explicit PROTOBUF_CONSTEXPR AgentState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentState(const AgentState& from);
  AgentState(AgentState&& from) noexcept
    : AgentState() {
    *this = ::std::move(from);
  }

  inline AgentState& operator=(const AgentState& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentState& operator=(AgentState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentState& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentState* internal_default_instance() {
    return reinterpret_cast<const AgentState*>(
               &_AgentState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AgentState& a, AgentState& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentState& from) {
    AgentState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgentState";
  }
  protected:
  explicit AgentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUptimeSFieldNumber = 1,
  };
  // uint32 uptime_s = 1;
  void clear_uptime_s();
  uint32_t uptime_s() const;
  void set_uptime_s(uint32_t value);
  private:
  uint32_t _internal_uptime_s() const;
  void _internal_set_uptime_s(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AgentState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t uptime_s_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopendrip_2dmsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DeviceInfo

// string name = 1;
inline void DeviceInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeviceInfo::name() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInfo.name)
}
inline std::string* DeviceInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.name)
  return _s;
}
inline const std::string& DeviceInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeviceInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_name() {
  // @@protoc_insertion_point(field_release:DeviceInfo.name)
  return _impl_.name_.Release();
}
inline void DeviceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.name)
}

// map<string, string> properties = 2;
inline int DeviceInfo::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int DeviceInfo::properties_size() const {
  return _internal_properties_size();
}
inline void DeviceInfo::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeviceInfo::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeviceInfo::properties() const {
  // @@protoc_insertion_point(field_map:DeviceInfo.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeviceInfo::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeviceInfo::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:DeviceInfo.properties)
  return _internal_mutable_properties();
}

// .DeviceType standard_type = 3;
inline bool DeviceInfo::_internal_has_standard_type() const {
  return device_type_case() == kStandardType;
}
inline bool DeviceInfo::has_standard_type() const {
  return _internal_has_standard_type();
}
inline void DeviceInfo::set_has_standard_type() {
  _impl_._oneof_case_[0] = kStandardType;
}
inline void DeviceInfo::clear_standard_type() {
  if (_internal_has_standard_type()) {
    _impl_.device_type_.standard_type_ = 0;
    clear_has_device_type();
  }
}
inline ::DeviceType DeviceInfo::_internal_standard_type() const {
  if (_internal_has_standard_type()) {
    return static_cast< ::DeviceType >(_impl_.device_type_.standard_type_);
  }
  return static_cast< ::DeviceType >(0);
}
inline ::DeviceType DeviceInfo::standard_type() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.standard_type)
  return _internal_standard_type();
}
inline void DeviceInfo::_internal_set_standard_type(::DeviceType value) {
  if (!_internal_has_standard_type()) {
    clear_device_type();
    set_has_standard_type();
  }
  _impl_.device_type_.standard_type_ = value;
}
inline void DeviceInfo::set_standard_type(::DeviceType value) {
  _internal_set_standard_type(value);
  // @@protoc_insertion_point(field_set:DeviceInfo.standard_type)
}

// string custom_type = 4;
inline bool DeviceInfo::_internal_has_custom_type() const {
  return device_type_case() == kCustomType;
}
inline bool DeviceInfo::has_custom_type() const {
  return _internal_has_custom_type();
}
inline void DeviceInfo::set_has_custom_type() {
  _impl_._oneof_case_[0] = kCustomType;
}
inline void DeviceInfo::clear_custom_type() {
  if (_internal_has_custom_type()) {
    _impl_.device_type_.custom_type_.Destroy();
    clear_has_device_type();
  }
}
inline const std::string& DeviceInfo::custom_type() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.custom_type)
  return _internal_custom_type();
}
template <typename ArgT0, typename... ArgT>
inline void DeviceInfo::set_custom_type(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_custom_type()) {
    clear_device_type();
    set_has_custom_type();
    _impl_.device_type_.custom_type_.InitDefault();
  }
  _impl_.device_type_.custom_type_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInfo.custom_type)
}
inline std::string* DeviceInfo::mutable_custom_type() {
  std::string* _s = _internal_mutable_custom_type();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.custom_type)
  return _s;
}
inline const std::string& DeviceInfo::_internal_custom_type() const {
  if (_internal_has_custom_type()) {
    return _impl_.device_type_.custom_type_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DeviceInfo::_internal_set_custom_type(const std::string& value) {
  if (!_internal_has_custom_type()) {
    clear_device_type();
    set_has_custom_type();
    _impl_.device_type_.custom_type_.InitDefault();
  }
  _impl_.device_type_.custom_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_custom_type() {
  if (!_internal_has_custom_type()) {
    clear_device_type();
    set_has_custom_type();
    _impl_.device_type_.custom_type_.InitDefault();
  }
  return _impl_.device_type_.custom_type_.Mutable(      GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_custom_type() {
  // @@protoc_insertion_point(field_release:DeviceInfo.custom_type)
  if (_internal_has_custom_type()) {
    clear_has_device_type();
    return _impl_.device_type_.custom_type_.Release();
  } else {
    return nullptr;
  }
}
inline void DeviceInfo::set_allocated_custom_type(std::string* custom_type) {
  if (has_device_type()) {
    clear_device_type();
  }
  if (custom_type != nullptr) {
    set_has_custom_type();
    _impl_.device_type_.custom_type_.InitAllocated(custom_type, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.custom_type)
}

// .DeviceUnits standard_unit = 5;
inline bool DeviceInfo::_internal_has_standard_unit() const {
  return device_units_case() == kStandardUnit;
}
inline bool DeviceInfo::has_standard_unit() const {
  return _internal_has_standard_unit();
}
inline void DeviceInfo::set_has_standard_unit() {
  _impl_._oneof_case_[1] = kStandardUnit;
}
inline void DeviceInfo::clear_standard_unit() {
  if (_internal_has_standard_unit()) {
    _impl_.device_units_.standard_unit_ = 0;
    clear_has_device_units();
  }
}
inline ::DeviceUnits DeviceInfo::_internal_standard_unit() const {
  if (_internal_has_standard_unit()) {
    return static_cast< ::DeviceUnits >(_impl_.device_units_.standard_unit_);
  }
  return static_cast< ::DeviceUnits >(0);
}
inline ::DeviceUnits DeviceInfo::standard_unit() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.standard_unit)
  return _internal_standard_unit();
}
inline void DeviceInfo::_internal_set_standard_unit(::DeviceUnits value) {
  if (!_internal_has_standard_unit()) {
    clear_device_units();
    set_has_standard_unit();
  }
  _impl_.device_units_.standard_unit_ = value;
}
inline void DeviceInfo::set_standard_unit(::DeviceUnits value) {
  _internal_set_standard_unit(value);
  // @@protoc_insertion_point(field_set:DeviceInfo.standard_unit)
}

// string custom_unit = 6;
inline bool DeviceInfo::_internal_has_custom_unit() const {
  return device_units_case() == kCustomUnit;
}
inline bool DeviceInfo::has_custom_unit() const {
  return _internal_has_custom_unit();
}
inline void DeviceInfo::set_has_custom_unit() {
  _impl_._oneof_case_[1] = kCustomUnit;
}
inline void DeviceInfo::clear_custom_unit() {
  if (_internal_has_custom_unit()) {
    _impl_.device_units_.custom_unit_.Destroy();
    clear_has_device_units();
  }
}
inline const std::string& DeviceInfo::custom_unit() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.custom_unit)
  return _internal_custom_unit();
}
template <typename ArgT0, typename... ArgT>
inline void DeviceInfo::set_custom_unit(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_custom_unit()) {
    clear_device_units();
    set_has_custom_unit();
    _impl_.device_units_.custom_unit_.InitDefault();
  }
  _impl_.device_units_.custom_unit_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceInfo.custom_unit)
}
inline std::string* DeviceInfo::mutable_custom_unit() {
  std::string* _s = _internal_mutable_custom_unit();
  // @@protoc_insertion_point(field_mutable:DeviceInfo.custom_unit)
  return _s;
}
inline const std::string& DeviceInfo::_internal_custom_unit() const {
  if (_internal_has_custom_unit()) {
    return _impl_.device_units_.custom_unit_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DeviceInfo::_internal_set_custom_unit(const std::string& value) {
  if (!_internal_has_custom_unit()) {
    clear_device_units();
    set_has_custom_unit();
    _impl_.device_units_.custom_unit_.InitDefault();
  }
  _impl_.device_units_.custom_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_custom_unit() {
  if (!_internal_has_custom_unit()) {
    clear_device_units();
    set_has_custom_unit();
    _impl_.device_units_.custom_unit_.InitDefault();
  }
  return _impl_.device_units_.custom_unit_.Mutable(      GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_custom_unit() {
  // @@protoc_insertion_point(field_release:DeviceInfo.custom_unit)
  if (_internal_has_custom_unit()) {
    clear_has_device_units();
    return _impl_.device_units_.custom_unit_.Release();
  } else {
    return nullptr;
  }
}
inline void DeviceInfo::set_allocated_custom_unit(std::string* custom_unit) {
  if (has_device_units()) {
    clear_device_units();
  }
  if (custom_unit != nullptr) {
    set_has_custom_unit();
    _impl_.device_units_.custom_unit_.InitAllocated(custom_unit, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceInfo.custom_unit)
}

// uint32 min_msg_interval_ms = 7;
inline void DeviceInfo::clear_min_msg_interval_ms() {
  _impl_.min_msg_interval_ms_ = 0u;
}
inline uint32_t DeviceInfo::_internal_min_msg_interval_ms() const {
  return _impl_.min_msg_interval_ms_;
}
inline uint32_t DeviceInfo::min_msg_interval_ms() const {
  // @@protoc_insertion_point(field_get:DeviceInfo.min_msg_interval_ms)
  return _internal_min_msg_interval_ms();
}
inline void DeviceInfo::_internal_set_min_msg_interval_ms(uint32_t value) {
  
  _impl_.min_msg_interval_ms_ = value;
}
inline void DeviceInfo::set_min_msg_interval_ms(uint32_t value) {
  _internal_set_min_msg_interval_ms(value);
  // @@protoc_insertion_point(field_set:DeviceInfo.min_msg_interval_ms)
}

inline bool DeviceInfo::has_device_type() const {
  return device_type_case() != DEVICE_TYPE_NOT_SET;
}
inline void DeviceInfo::clear_has_device_type() {
  _impl_._oneof_case_[0] = DEVICE_TYPE_NOT_SET;
}
inline bool DeviceInfo::has_device_units() const {
  return device_units_case() != DEVICE_UNITS_NOT_SET;
}
inline void DeviceInfo::clear_has_device_units() {
  _impl_._oneof_case_[1] = DEVICE_UNITS_NOT_SET;
}
inline DeviceInfo::DeviceTypeCase DeviceInfo::device_type_case() const {
  return DeviceInfo::DeviceTypeCase(_impl_._oneof_case_[0]);
}
inline DeviceInfo::DeviceUnitsCase DeviceInfo::device_units_case() const {
  return DeviceInfo::DeviceUnitsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// DeviceConfig

// .DeviceMode device_mode = 1;
inline void DeviceConfig::clear_device_mode() {
  _impl_.device_mode_ = 0;
}
inline ::DeviceMode DeviceConfig::_internal_device_mode() const {
  return static_cast< ::DeviceMode >(_impl_.device_mode_);
}
inline ::DeviceMode DeviceConfig::device_mode() const {
  // @@protoc_insertion_point(field_get:DeviceConfig.device_mode)
  return _internal_device_mode();
}
inline void DeviceConfig::_internal_set_device_mode(::DeviceMode value) {
  
  _impl_.device_mode_ = value;
}
inline void DeviceConfig::set_device_mode(::DeviceMode value) {
  _internal_set_device_mode(value);
  // @@protoc_insertion_point(field_set:DeviceConfig.device_mode)
}

// uint32 msg_interval_ms = 2;
inline void DeviceConfig::clear_msg_interval_ms() {
  _impl_.msg_interval_ms_ = 0u;
}
inline uint32_t DeviceConfig::_internal_msg_interval_ms() const {
  return _impl_.msg_interval_ms_;
}
inline uint32_t DeviceConfig::msg_interval_ms() const {
  // @@protoc_insertion_point(field_get:DeviceConfig.msg_interval_ms)
  return _internal_msg_interval_ms();
}
inline void DeviceConfig::_internal_set_msg_interval_ms(uint32_t value) {
  
  _impl_.msg_interval_ms_ = value;
}
inline void DeviceConfig::set_msg_interval_ms(uint32_t value) {
  _internal_set_msg_interval_ms(value);
  // @@protoc_insertion_point(field_set:DeviceConfig.msg_interval_ms)
}

// -------------------------------------------------------------------

// DeviceState

// string value = 1;
inline void DeviceState::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& DeviceState::value() const {
  // @@protoc_insertion_point(field_get:DeviceState.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceState::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceState.value)
}
inline std::string* DeviceState::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:DeviceState.value)
  return _s;
}
inline const std::string& DeviceState::_internal_value() const {
  return _impl_.value_.Get();
}
inline void DeviceState::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceState::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceState::release_value() {
  // @@protoc_insertion_point(field_release:DeviceState.value)
  return _impl_.value_.Release();
}
inline void DeviceState::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceState.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerInfo

// string name = 1;
inline void ControllerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ControllerInfo::name() const {
  // @@protoc_insertion_point(field_get:ControllerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControllerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ControllerInfo.name)
}
inline std::string* ControllerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ControllerInfo.name)
  return _s;
}
inline const std::string& ControllerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ControllerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ControllerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ControllerInfo::release_name() {
  // @@protoc_insertion_point(field_release:ControllerInfo.name)
  return _impl_.name_.Release();
}
inline void ControllerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ControllerInfo.name)
}

// map<string, string> properties = 2;
inline int ControllerInfo::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int ControllerInfo::properties_size() const {
  return _internal_properties_size();
}
inline void ControllerInfo::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerInfo::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerInfo::properties() const {
  // @@protoc_insertion_point(field_map:ControllerInfo.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerInfo::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerInfo::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ControllerInfo.properties)
  return _internal_mutable_properties();
}

// repeated string devices = 3;
inline int ControllerInfo::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int ControllerInfo::devices_size() const {
  return _internal_devices_size();
}
inline void ControllerInfo::clear_devices() {
  _impl_.devices_.Clear();
}
inline std::string* ControllerInfo::add_devices() {
  std::string* _s = _internal_add_devices();
  // @@protoc_insertion_point(field_add_mutable:ControllerInfo.devices)
  return _s;
}
inline const std::string& ControllerInfo::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const std::string& ControllerInfo::devices(int index) const {
  // @@protoc_insertion_point(field_get:ControllerInfo.devices)
  return _internal_devices(index);
}
inline std::string* ControllerInfo::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ControllerInfo.devices)
  return _impl_.devices_.Mutable(index);
}
inline void ControllerInfo::set_devices(int index, const std::string& value) {
  _impl_.devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ControllerInfo.devices)
}
inline void ControllerInfo::set_devices(int index, std::string&& value) {
  _impl_.devices_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ControllerInfo.devices)
}
inline void ControllerInfo::set_devices(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ControllerInfo.devices)
}
inline void ControllerInfo::set_devices(int index, const char* value, size_t size) {
  _impl_.devices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ControllerInfo.devices)
}
inline std::string* ControllerInfo::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline void ControllerInfo::add_devices(const std::string& value) {
  _impl_.devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ControllerInfo.devices)
}
inline void ControllerInfo::add_devices(std::string&& value) {
  _impl_.devices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ControllerInfo.devices)
}
inline void ControllerInfo::add_devices(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ControllerInfo.devices)
}
inline void ControllerInfo::add_devices(const char* value, size_t size) {
  _impl_.devices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ControllerInfo.devices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ControllerInfo::devices() const {
  // @@protoc_insertion_point(field_list:ControllerInfo.devices)
  return _impl_.devices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ControllerInfo::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ControllerInfo.devices)
  return &_impl_.devices_;
}

// -------------------------------------------------------------------

// ControllerConfig

// -------------------------------------------------------------------

// ControllerState

// uint32 uptime_s = 1;
inline void ControllerState::clear_uptime_s() {
  _impl_.uptime_s_ = 0u;
}
inline uint32_t ControllerState::_internal_uptime_s() const {
  return _impl_.uptime_s_;
}
inline uint32_t ControllerState::uptime_s() const {
  // @@protoc_insertion_point(field_get:ControllerState.uptime_s)
  return _internal_uptime_s();
}
inline void ControllerState::_internal_set_uptime_s(uint32_t value) {
  
  _impl_.uptime_s_ = value;
}
inline void ControllerState::set_uptime_s(uint32_t value) {
  _internal_set_uptime_s(value);
  // @@protoc_insertion_point(field_set:ControllerState.uptime_s)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AgentInfo

// string name = 1;
inline void AgentInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AgentInfo::name() const {
  // @@protoc_insertion_point(field_get:AgentInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgentInfo.name)
}
inline std::string* AgentInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:AgentInfo.name)
  return _s;
}
inline const std::string& AgentInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AgentInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_name() {
  // @@protoc_insertion_point(field_release:AgentInfo.name)
  return _impl_.name_.Release();
}
inline void AgentInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgentInfo.name)
}

// map<string, string> properties = 2;
inline int AgentInfo::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int AgentInfo::properties_size() const {
  return _internal_properties_size();
}
inline void AgentInfo::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentInfo::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentInfo::properties() const {
  // @@protoc_insertion_point(field_map:AgentInfo.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentInfo::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentInfo::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:AgentInfo.properties)
  return _internal_mutable_properties();
}

// repeated string controllers = 3;
inline int AgentInfo::_internal_controllers_size() const {
  return _impl_.controllers_.size();
}
inline int AgentInfo::controllers_size() const {
  return _internal_controllers_size();
}
inline void AgentInfo::clear_controllers() {
  _impl_.controllers_.Clear();
}
inline std::string* AgentInfo::add_controllers() {
  std::string* _s = _internal_add_controllers();
  // @@protoc_insertion_point(field_add_mutable:AgentInfo.controllers)
  return _s;
}
inline const std::string& AgentInfo::_internal_controllers(int index) const {
  return _impl_.controllers_.Get(index);
}
inline const std::string& AgentInfo::controllers(int index) const {
  // @@protoc_insertion_point(field_get:AgentInfo.controllers)
  return _internal_controllers(index);
}
inline std::string* AgentInfo::mutable_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:AgentInfo.controllers)
  return _impl_.controllers_.Mutable(index);
}
inline void AgentInfo::set_controllers(int index, const std::string& value) {
  _impl_.controllers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:AgentInfo.controllers)
}
inline void AgentInfo::set_controllers(int index, std::string&& value) {
  _impl_.controllers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:AgentInfo.controllers)
}
inline void AgentInfo::set_controllers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.controllers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AgentInfo.controllers)
}
inline void AgentInfo::set_controllers(int index, const char* value, size_t size) {
  _impl_.controllers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AgentInfo.controllers)
}
inline std::string* AgentInfo::_internal_add_controllers() {
  return _impl_.controllers_.Add();
}
inline void AgentInfo::add_controllers(const std::string& value) {
  _impl_.controllers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AgentInfo.controllers)
}
inline void AgentInfo::add_controllers(std::string&& value) {
  _impl_.controllers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AgentInfo.controllers)
}
inline void AgentInfo::add_controllers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.controllers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AgentInfo.controllers)
}
inline void AgentInfo::add_controllers(const char* value, size_t size) {
  _impl_.controllers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AgentInfo.controllers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentInfo::controllers() const {
  // @@protoc_insertion_point(field_list:AgentInfo.controllers)
  return _impl_.controllers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentInfo::mutable_controllers() {
  // @@protoc_insertion_point(field_mutable_list:AgentInfo.controllers)
  return &_impl_.controllers_;
}

// -------------------------------------------------------------------

// AgentConfig

// -------------------------------------------------------------------

// AgentState

// uint32 uptime_s = 1;
inline void AgentState::clear_uptime_s() {
  _impl_.uptime_s_ = 0u;
}
inline uint32_t AgentState::_internal_uptime_s() const {
  return _impl_.uptime_s_;
}
inline uint32_t AgentState::uptime_s() const {
  // @@protoc_insertion_point(field_get:AgentState.uptime_s)
  return _internal_uptime_s();
}
inline void AgentState::_internal_set_uptime_s(uint32_t value) {
  
  _impl_.uptime_s_ = value;
}
inline void AgentState::set_uptime_s(uint32_t value) {
  _internal_set_uptime_s(value);
  // @@protoc_insertion_point(field_set:AgentState.uptime_s)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceType>() {
  return ::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::DeviceUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceUnits>() {
  return ::DeviceUnits_descriptor();
}
template <> struct is_proto_enum< ::DeviceMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceMode>() {
  return ::DeviceMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fopendrip_2dmsg_2eproto
